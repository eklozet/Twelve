proposition : type.

true : proposition.
false : proposition.
not : proposition -> proposition.
and : proposition -> proposition -> proposition.
or  : proposition -> proposition -> proposition.
imply : proposition -> proposition -> proposition.

%abbrev
equivalence : proposition -> proposition -> proposition =
  [A : proposition]
    [B : proposition]
      and (imply A B) (imply B A).

provable : proposition -> type.

true_i : provable true.
false_e : provable false -> provable A.

%{ encoding negation as implying false
not_i : (provable A -> provable false) -> provable (not A).
not_e : provable (not A) -> provable A -> provable false.
}%
not_i : (provable A -> {p : proposition} provable p) -> provable (not A).
not_e : provable (not A) -> provable A -> {C : proposition} provable C.

and_i  : provable A -> provable B -> provable (and A B).
and_e1 : provable (and A B) -> provable P.
and_e2 : provable (and A B) -> provable B.

or_i1 : provable A -> provable (or A B).
or_i2 : provable B -> provable (or A B).
or_e  : provable (or A B) -> (provable A -> provable C) -> (provable B -> provable C) -> provable C.

imply_i : (provable A -> provable B) -> provable (imply A B).
imply_e : provable (imply A B) -> provable A -> provable B.

admit : {A : proposition} provable A.


s_combinator : provable (imply A B) -> provable (imply A (imply B C)) -> provable A -> provable C =
  [p : provable (imply A B)]
    [q : provable (imply A (imply B C))]
      [r : provable A]
        imply_e (imply_e q r) (imply_e p r).

transitivity : provable (imply A B) -> provable (imply B C) -> provable (imply A C) =
  [p : provable (imply A B)]
    [q : provable (imply B C)]
      imply_i ([r : provable A]
              imply_e q (imply_e p r) ).

weakening : provable (imply A B) -> provable (imply A (imply C B)) =
  [p : provable (imply A B)]
    imply_i ([q : provable A]
            imply_i ([_ : provable C]
                    imply_e p q ) ).

identity : provable (imply A A) =
  imply_i ([p : provable A] p).

contraction : provable (imply A (imply A B)) -> provable (imply A B) =
  [p : provable (imply A (imply A B))]
    imply_i ([q : provable A]
            imply_e (imply_e p q) q ).

exchange : provable (imply A (imply B C)) -> provable (imply B (imply A C)) =
  [p : provable (imply A (imply B C))]
    imply_i ([q : provable B]
            imply_i ([r : provable A]
                    imply_e (imply_e p r) q) ).

and_symmetry : provable (and A B) -> provable (and B A) =
  [p : provable (and A B)]
    and_i (and_e2 p) (and_e1 p).

curry : provable (imply (and A B) C) -> provable (imply A (imply B C)) =
  [p : provable (imply (and A B) C)]
    imply_i ([q : provable A]
            imply_i ([r : provable B] imply_e p (and_i q r)) ).

uncurry : provable (imply A (imply B C)) -> provable (imply (and A B) C) =
  [p : provable (imply A (imply B C))]
    imply_i ([q : provable (and A B)]
            imply_e (imply_e p (and_e1 q)) (and_e2 q) ).

or_not_imply : provable (or (not A) B) -> provable (imply A B) =
  [p : provable (or (not A) B)]
    imply_i ([q : provable A]
            or_e p ([r : provable (not A)]
		     false_e (not_e r q) )
	           ([s : provable B] s) ) .

